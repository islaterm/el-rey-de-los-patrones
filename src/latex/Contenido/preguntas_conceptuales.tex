\section{Preguntas conceptuales}
\begin{enumerate}
  
  \item ¿Qué beneficios tiene escribir los tests primero?
  \item Nombre las etapas de \textit{TDD} y de una breve descripción de cada uno.
  \item ¿Qué es un test unitario? ¿Para qué se usan?
  \item ¿Qué diferencia un \textit{framework} de una librería?
  \item Si un programa tiene 100 \% de \textit{coverage} ¿Significa esto que el programa 
    no tiene errores? Explique.
  \item Se tiene la siguiente implementación de un inventario. Cree los tests necesarios 
    para probar el funcionamiento del programa.
    \inputminted{java}{listings/Inventario.java}
  \item Usted tiene un computador en el que desea escribir programas en \textit{Python} y 
    \textit{Java}. Para editar los archivos usted tiene 3 \textit{IDEs}: \textit{PyCharm},
    \textit{IntelliJ} y \textit{VSCode}. Cada editor puede abrir distintos tipos de 
    archivos, \textit{PyCharm} solamente puede abrir programas escritos en 
    \textit{Python}, \textit{IntelliJ} archivos \textit{Java}, mientras que 
    \textit{VSCode} puede abrir ambos tipos. Una posible implementación de esto se ve a 
    continuación. Comente qué le parece la implementación propuesta.
    \inputminted{java}{listings/Archivos.java}
  \item ¿Por qué es una mala práctica usar \mintinline{java}{instanceof}? ¿En qué casos es
    válido usarlo?
  \item ¿Cuáles son las etapas de desarrollo iterativo?
  \item De un ejemplo concreto de un problema en el que utilizaría 
    \textit{Adapter Pattern}
  \item ¿Para qué se ocupa \textit{Proxy Pattern}?
  \item Ilustre mediante diagramas \textit{UML} los patrones \textit{Adapter} y 
    \textit{Proxy}
  \item Suponga que tiene una aplicación para realizar cálculos matemáticos en un 
    servidor.
    Los usuarios de la aplicación acceden desde su navegador e ingresan en formato texto
    la expresión que quiere calcular.
    Sin embargo, para que el servidor realice un cálculo, debe recibir un objeto de tipo 
    \textit{MathematicalExpression}.
    Señale que patrón de diseño utilizaría para resolver este problema y haga un diagrama
    \textit{UML} para ilustrar su solución.
  \item Señale las diferencias entre el \textit{Observer} antiguo de \textit{Java} y el 
    nuevo. ¿Por qué se implementó este cambio?
  \item ¿Por qué es mejor utilizar \textit{Observer} para notificar cambios de propiedades
    en vez de hacer que la clase notifique directamente?
  \item ¿En qué casos recomendaría el uso de \textit{Factory Pattern}? ¿En cuáles no?
  \item Muestre con un diagrama \textit{UML} un ejemplo de uso de \textit{Factory}.
\end{enumerate}